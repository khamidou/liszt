#!/usr/bin/env python
#coding=utf8
from __future__ import with_statement
# 

import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError, URLError
import subprocess
import fnmatch
import tempfile
import datetime
import locale
import codecs

try:
    import json 
except ImportError:
    import simplejson as json                                                                                                                         

# unicode magic.
sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)

def help():
    print "liszt c|create listname [optional entry text]"
    print "liszt r[remove|delete listname [optional entry index]"
    print "liszt s|show listname [optional entry index]"
    print "liszt chk|check listname index"
    print "liszt a|add listname"
    print "liszt u|update listname"
    

def bailout(msg):
    print msg
    sys.exit(-1)

def create_spool_file(dict):
# Create a spool file and save dict inside as a json dict.
    fd, filename = tempfile.mkstemp(dir=os.path.expanduser('~/.liszt/delayed/'))
    os.write(fd, json.dumps(dict))
    os.close(fd)
    
class CachedList(object):
    def __init__(self, listname):
        try:
            self.listname = listname
            fd = open(os.path.expanduser('~/.liszt/cached/') + listname)
            try:
                self.cached_list = json.load(fd)
            except ValueError:
                bailout("List <%s> is not a valid json file" % listname)

        except IOError:
            # Create it.
            try:
                fd = open(os.path.expanduser('~/.liszt/cached/') + listname, 'w+')
            except IOError:
                bailout("IOError when trying to create a cached list.")
            
            self.cached_list = {"name" : listname, "contents" : []}

    def save(self):
        fd = open(os.path.expanduser('~/.liszt/cached/') + self.listname, 'w+')
        json.dump(self.cached_list, fd, encoding="utf8")
    
    def fget(self):
        return self.cached_list
    
    def fset(self, list):
        self.cached_list = list

    def fdel(self):
        del self.cached_list
        
    contents = property(fget, fset, fdel)

class CommandParser(object):
    def __init__(self, args):
        self.dispatch = {"create" : self.parse_create,
                         "c" : self.parse_create,
                         "touch" : self.parse_create,
                         "remove" : self.parse_remove,
                         "rem" : self.parse_remove,
                         "rm" : self.parse_remove,
                         "show" :   self.parse_show, 
                         "s" :   self.parse_show,
                         "update" : self.parse_update,
                         "add" : self.parse_add,
                      }

        if args[0] in self.dispatch:
            self.dispatch[args[0]](args[1:])

    def parse_create(self, args):
        listname = ""
        entryname = ""
        spldict = {} # The dictionnary saved in a spool file.

        if len(args) == 0:
            bailout("liszt create listname [optional entry name]")

        listname = args[0]

        if len(args) == 2:
            entryname = args[1]
        elif len(args) > 2:
            # It means that we've got something like "liszt create mylist buy something from the grocery store"
            def addstr(x, y):
                # A special function to add spaces between to added words - yes, it doesn't preserve tabulations and the likes,
                # but, you asked for it.
                return x + " " + y
            entryname = reduce(addstr, args[1:])
        
        if entryname == "":
            spldict["request"] = "create-list"
            spldict["listname"] = listname
            cached_list = CachedList(listname)
            cached_list.save()

            lists_list = CachedList("lists_list")
            lists_list.contents.append(listname)
            lists_list.save()
            
            
        else:
            spldict["request"] = "create-entry"
            spldict["listname"] = listname
            spldict["content"] = dict()
            spldict["content"]["title"] = entryname # FIXME : specify the other options.

            cached_list = CachedList(listname)
            entry = {"title" : entryname, "done" : 0, "date" : str(datetime.datetime.now())} # FIXME : specify the other options.
            cached_list.contents["contents"].append(entry)
            cached_list.save()

        create_spool_file(spldict)
            

    def parse_show(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            print "List of the created lists :"
            lists_list = CachedList("lists_list")

            for list in lists_list.contents:
                cl = CachedList(list)
                if "deleted" not in cl.contents:
                    print list

        if len(args) == 1:
            list = CachedList(args[0])

            for entry in list.contents["contents"]:
                if "deleted" not in entry:
                    print entry["title"] + "\t" + entry["date"]

        elif len(args) == 2:
            list = CachedList(args[0])
            index = int(args[1])
            try:
                entry = list.contents["contents"][index]
            except IndexError:
                bailout("Invalid entry index.")

            print entry["title"] + "\t" + entry["date"]

    def parse_remove(self, args):
        if len(args) == 0 or len(args) > 2:
            bailout("liszt remove listname [optional entry index]")

        listname = ""
        index = ""
        spldict = {} # The dictionnary saved in a spool file.

        listname = args[0]
        list = CachedList(listname)

        if len(args) == 2:
            index = int(args[1])
            spldict["request"] = "delete-entry"
            spldict["index"] = index
            spldict["listname"] = listname

            list.contents["contents"][index]["deleted"] = 1
            list.save()

        else:
            spldict["request"] = "delete-list"
            spldict["listname"] = listname

            list.contents["deleted"] = 1
            list.save()

        create_spool_file(spldict)
        
    
    def parse_update(self, args):

        listname = ""

        if len(args) == 0:
            bailout("liszt update listname [optional entry index]")

        listname = args[0]

        if len(args) == 1:
            fd, filename = tempfile.mkstemp()

            l = CachedList(listname)
            entries = l.contents["contents"]

            for entry in entries:
                str = "+\t%s\t%s\t%s\n" % (entry["title"], entry["date"], entry["done"])
                os.write(fd, str)

            editor = os.getenv("EDITOR")
            os.system(editor + " " + filename)
            os.close(fd)
            
            # Now, reopen the fd, as a python file handle.
            fd = open(filename)
            lines = fd.read().split('+')

            for i, line in enumerate(lines):
                fields = line.split("\t")
                if len(fields) != 4:
                    bailout("Error at line %d : one of the fields is not correctly formatted." % i)

                dict = {"request" : "update-entry", "listname" : listname,
                        "index" : i, "contents" : {"title" : fields[1], "date" : fields[2], "done": fields[3]}}

                create_spool_file(dict)

                # Also update the cached list
                try:
                    with l.contents["contents"][i] as entry:
                        entry["title"] = fields[1]
                        entry["date"] = fields[2]
                        entry["done"] = fields[3]
                except IndexError:
                    continue

            os.unlink(filename)

    def parse_add(self, args):
        listname = ""

        if len(args) == 0:
            bailout("liszt add listname ")

        listname = args[0]

        fd, filename = tempfile.mkstemp()

        editor = os.getenv("EDITOR")
        if editor == None:
            editor = "vi"  # Not my editor of choice but it should work everywhere.
        
        os.system(("%s %s" % (editor, filename)))
        
        # Now, reopen the fd, as a python file handle.
        fd = open(filename)
        lines = fd.read().split('+')

        for i, line in enumerate(lines):
            # fields = lines[i].split("\t")  FIXME: add support for different fields on a line.
            
            if line != '':
                title = unicode(line.strip(), encoding="utf8")
                dict = {"request" : "create-entry", "listname" : listname, "content" : {"title" : title}}
                create_spool_file(dict)
                cached_list = CachedList(listname)

                entry = {"title" : title, "done" : 0, "date" : str(datetime.datetime.now())} 
                cached_list.contents["contents"].append(entry)
                cached_list.save()

        os.unlink(filename)

if __name__ == "__main__":

    if len(sys.argv) <= 1:
        help()
        sys.exit(0)

    parser = CommandParser(sys.argv[1:])
