#!/usr/bin/env python
# 

import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError, URLError
import subprocess
from subprocess import Popen
import fnmatch
import tempfile
import datetime

try:
    import json 
except ImportError:
    import simplejson as json                                                                                                                         


def help():
    print "liszt c|create listname ?entryname? "
    print "liszt r[remove|d|delete listname ?entryindex?"
    print "liszt s listname ?entryindex?"
    print "liszt chk|check listname index"
    print "liszt u|update listname"
    

def bailout(msg):
    print msg
    sys.exit(-1)

def create_spool_file(dict):
# Create a spool file and save dict inside as a json dict.
    fd, filename = tempfile.mkstemp(dir=os.path.expanduser('~/.liszt/delayed/'))
    os.write(fd, json.dumps(dict))
    os.close(fd)
    
class CachedList(object):
    def __init__(self, listname):
        try:
            self.listname = listname
            fd = open(os.path.expanduser('~/.liszt/cached/') + listname)
            try:
                self.cached_list = json.load(fd)
            except ValueError:
                bailout("List <%s> is not a valid json file" % listname)

        except IOError:
            # Create it.
            try:
                fd = open(os.path.expanduser('~/.liszt/cached/') + listname, 'w+')
            except IOError:
                bailout("IOError when trying to create a cached list.")
            
            self.cached_list = {"name" : listname, "contents" : []}

    def save(self):
        fd = open(os.path.expanduser('~/.liszt/cached/') + self.listname, 'w+')
        json.dump(self.cached_list, fd)
    
    def fget(self):
        return self.cached_list
    
    def fset(self, list):
        self.cached_list = list

    def fdel(self):
        del self.cached_list
        
    contents = property(fget, fset, fdel)

class CommandParser(object):
    def __init__(self, args):
        self.dispatch = {"create" : self.parse_create,
                         "c" : self.parse_create,
                         "touch" : self.parse_create,
                         "remove" : self.parse_remove,
                         "rem" : self.parse_remove,
                         "rm" : self.parse_remove,
                         "show" :   self.parse_show, 
                         "s" :   self.parse_show,
                         "update" : self.parse_update,
                         "add" : self.parse_add,
                      }

        if args[0] in self.dispatch:
            self.dispatch[args[0]](args[1:])

    def parse_create(self, args):
        listname = ""
        entryname = ""
        spldict = {} # The dictionnary saved in a spool file.

        if len(args) == 0:
            bailout("liszt create listname [optional entry name]")

        listname = args[0]

        if len(args) == 2:
            entryname = args[1]
        elif len(args) > 2:
            # It means that we've got something like "liszt create mylist buy something from the grocery store"
            def addstr(x, y):
                # A special function to add spaces between to added words - yes, it doesn't preserve tabulations and the likes,
                # but, you asked for it.
                return x + " " + y
            entryname = reduce(addstr, args[1:])
        
        if entryname == "":
            spldict["request"] = "create-list"
            spldict["listname"] = listname
            cached_list = CachedList(listname)
            cached_list.save()

            lists_list = CachedList("lists_list")
            lists_list.contents.append(listname)
            lists_list.save()
            
            
        else:
            spldict["request"] = "create-entry"
            spldict["listname"] = listname
            spldict["content"] = dict()
            spldict["content"]["title"] = entryname # FIXME : specify the other options.

            cached_list = CachedList(listname)
            entry = {"title" : entryname, "date" : str(datetime.datetime.now())} # FIXME : specify the other options.
            cached_list.contents["contents"].append(entry)
            cached_list.save()

        create_spool_file(spldict)
            

    def parse_show(self, args):
        listname = ""
        entryname = ""

        if sys.stdout.isatty():
            sys.stdout = os.popen('/bin/sh -c less -', 'w')

        if len(args) == 0:
            print "List of the created lists :"
            lists_list = CachedList("lists_list")

            for list in lists_list.contents:
                cl = CachedList(list)
                if "deleted" not in cl.contents:
                    print list

        if len(args) == 1:
            list = CachedList(args[0])

            for entry in list.contents["contents"]:
                if "deleted" not in entry:
                    print entry["title"] + "\t" + entry["date"]

        elif len(args) == 2:
            list = CachedList(args[0])
            index = int(args[1])
            try:
                entry = list.contents["contents"][index]
            except IndexError:
                bailout("Invalid entry index.")

            print entry["title"] + "\t" + entry["date"]

    def parse_remove(self, args):
        if len(args) == 0 or len(args) > 2:
            bailout("liszt remove listname [optional entry index]")

        listname = ""
        index = ""
        spldict = {} # The dictionnary saved in a spool file.

        listname = args[0]
        list = CachedList(listname)

        if len(args) == 2:
            index = int(args[1])
            spldict["request"] = "delete-entry"
            spldict["index"] = index
            spldict["listname"] = listname

            list.contents["contents"][index]["deleted"] = 1
            list.save()

        else:
            spldict["request"] = "delete-list"
            spldict["listname"] = listname

            list.contents["deleted"] = 1
            list.save()

        create_spool_file(spldict)
        
    
    def parse_update(self, args):

        listname = ""

        if len(args) == 0:
            bailout("liszt update listname [optional entry index]")

        listname = args[0]

        if len(args) == 1:
            fd, filename = tempfile.mkstemp()

            entries = session.get_list(listname)["contents"]

            for entry in entries:
                str = "+\t%s\t%s\t%s\n" % (entry["title"], entry["date"], entry["done"])
                os.write(fd, str)

            editor = os.getenv("EDITOR")
            os.system(editor + " " + filename)
            os.close(fd)
            
            # Now, reopen the fd, as a python file handle.
            fd = open(filename)
            lines = fd.read().split('+')

            for i in range(len(lines)):
                fields = lines[i].split("\t")
                if len(fields) != 4:
                    bailout("Error : one of the fields is not correctly formatted.") # FIXME : display the line number too.

                dict = {"request" : "update-entry", "listname" : listname,
                        "index" : i, "contents" : {"title" : fields[1], "date" : fields[2], "done": fields[3]}}

                create_spool_file(dict)

            os.unlink(filename)

    def parse_add(self, args):
        listname = ""

        if len(args) == 0:
            bailout("liszt add listname ")

        listname = args[0]

        fd, filename = tempfile.mkstemp()

        editor = os.getenv("EDITOR")
        os.system(editor + " " + filename)
        os.close(fd)
        
        # Now, reopen the fd, as a python file handle.
        fd = open(filename)
        lines = fd.read().split('+')

        for i in range(len(lines)):
            # fields = lines[i].split("\t")  FIXME: add support for different fields on a line.
            
            if lines[i] != '':
                dict = {"request" : "create-entry", "listname" : listname, "content" : {"title" : lines[i].rstrip().lstrip()}}
                create_spool_file(dict)

        os.unlink(filename)

if __name__ == "__main__":

    if len(sys.argv) <= 1:
        help()
        sys.exit(0)

    parser = CommandParser(sys.argv[1:])
