#!/usr/bin/env python
# 
import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError
import fnmatch

import ConfigParser

if sys.version_info[1] < 6: # py2.5-
    import simplejson as json                                                                                                                         
else: # py2.6
    import json 

base = "http://0.0.0.0:8080/api"

conf = ConfigParser.RawConfigParser()
conf.read(os.path.expanduser('~/.liszt/config'))

def bailout(msg):
    print msg
    sys.exit(-1)

class LisztSession:
    def __init__(self):

        self.jar = cookielib.LWPCookieJar()
        if os.path.isfile('~/.liszt/cookiejar'):
            self.jar.load('~/.liszt/cookiejar')

        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.jar))
        urllib2.install_opener(self.opener)
    
    def login(self, username, password):
        d = {'username' : username, 'password': password}
        ed = urllib.urlencode(d)
        try:
            urllib2.urlopen(base + "/login/", ed)
        except HTTPError:
            bailout("Unable to log you in - are you credentials correct ?")

    def create_list(self, listname):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to create the list " + listname)

    def create_list_entry(self, listname, entry):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/" + quote(entry) + "/")
        except HTTPError:
            bailout("Unable to create the list " + listname)

    def show_list(self, listname):
        ln = self.glob_listname(listname)

        try:
            req = urllib2.urlopen(base + "/get/" + quote(ln) + "/")
        except HTTPError:
            bailout("Unable to open the list " + listname)

        entries = json.load(req)

        for entry in entries["contents"]:
            print entry["title"] + "\t" + entry["date"]
            
    def remove_list(self, listname):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to remove the list " + listname)

    def remove_list_entry(self, listname, index):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/" + quote(index) + "/")
        except HTTPError:
            bailout("Unable to create the list " + listname)

    def glob_listname(self, pattern):
        
        def match_listname(l):
            # This function doesn't seem very pythonic...
            if len(l) > 1:
                print str(len(l)) + " lists satifisfy the pattern : "
                print l

                try:
                    pat = raw_input("Enter a matching pattern to clarify your choice : ")
                except EOFError:
                    sys.exit(-1)

                return match_listname(fnmatch.filter(l, pat))
            else:
                return l[0]

        try:
            req = urllib2.urlopen(base + "/getlists/")
            lists = json.load(req)
            res = fnmatch.filter(lists, pattern)

            if len(res) > 1:
                return match_listname(res)
            else:
                return res[0]

        except HTTPError:
            bailout("Unable to glob list pattern")

def help():
    print "liszt c|create listname ?entryname? "
    print "liszt r[remove|d|delete listname ?entryindex?"
    print "liszt s listname ?entryindex?"
    print "liszt chk|check listname index"
    print "liszt m|mod|modify listname index ?'new description'? ?'check'? ?'date'?"

def parse_create(args):
    pass

def parse_remove(args):
    pass

def parse_show(args):
    
    pass

dispatch = {"create" : parse_create,
            "remove" : parse_remove,
            "show" : parse_show, }

if __name__ == "__main__":

#     if len(sys.argv) <= 1:
#         help()
#         sys.exit(0)

    session = LisztSession()
    session.login("s", "s")
    session.show_list("*")

#     if sys.argv[1] in dispatch:
#         dispatch[sys.argv[1]](sys.argv[2:])
#     else:
#         # Assume the user just wants to see a list
#         parse_show(sys.argv[2:])
