#!/usr/bin/env python
# 
import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError, URLError
import subprocess
from subprocess import Popen
import fnmatch
import tempfile

import ConfigParser

try:
    import json 
except ImportError:
    import simplejson as json                                                                                                                         


base = "http://soundbush.com:8080/api/v1"

conf = ConfigParser.RawConfigParser()
conf.read(os.path.expanduser('~/.liszt/config'))
username = conf.get('Credentials', 'username')
password = conf.get('Credentials', 'password')

def help():
    print "liszt c|create listname ?entryname? "
    print "liszt r[remove|d|delete listname ?entryindex?"
    print "liszt s listname ?entryindex?"
    print "liszt chk|check listname index"
    print "liszt u|update listname index ?'new description'? ?'check'? ?'date'?"
    

def bailout(msg):
    print msg
    sys.exit(-1)

class LisztSession:
    def __init__(self):

        self.jar = cookielib.LWPCookieJar()
        if os.path.isfile('~/.liszt/cookiejar'):
            self.jar.load('~/.liszt/cookiejar')

        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.jar))
        urllib2.install_opener(self.opener)

    def login(self, username, password):
        d = {'username' : username, 'password': password}
        ed = urllib.urlencode(d)
        try:
            urllib2.urlopen(base + "/login/", ed)
        except HTTPError:
            bailout("Unable to log you in - are you credentials correct ?")
        except URLError:
            bailout("Unable to connect to the remote host.")

    def create_list(self, listname):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to create the list " + listname)

    def create_list_entry(self, listname, entry):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/" + quote(entry) + "/")
        except HTTPError:
            bailout("Unable to create the list entry in list " + listname)

    def get_lists_list(self):
        try:
            req = urllib2.urlopen(base + "/getlists/")
        except HTTPError:
            bailout("Unable to get a list of the available lists")
            
        return json.load(req)

    def get_list(self, listname):
        ln = self.glob_listname(listname)

        try:
            req = urllib2.urlopen(base + "/get/" + quote(ln) + "/")
        except HTTPError:
            bailout("Unable to open the list " + listname)

        return json.load(req)

    def get_entry(self, listname, index):
        ln = self.glob_listname(listname)

        try:
            req = urllib2.urlopen(base + "/get/" + quote(ln) + "/" + str(index) + "/")
        except HTTPError:
            bailout("Unable to get entry " + str(index) + " from list " + listname)

        return json.load(req)

    def remove_list(self, listname):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to remove the list " + listname)

    def remove_list_entry(self, listname, index):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/" + quote(index) + "/")
        except HTTPError:
            bailout("Unable to remove the entry " + index + "from list " + listname)

    def update_list_entry(self, listname, index, contents):
        ec = urllib.urlencode(contents)
        try:
            urllib2.urlopen(base + "/update/" + listname + "/" + str(index) + "/", ec)
        except HTTPError:
            bailout("Unable to update the list entry")
        
    def glob_listname(self, pattern):
        
        def match_listname(l):
            # This function doesn't seem very pythonic...
            if len(l) > 1:
                print str(len(l)) + " lists satifisfy the pattern : "
                print l

                try:
                    pat = raw_input("Enter a matching pattern to clarify your choice : ")
                except EOFError:
                    sys.exit(-1)

                return match_listname(fnmatch.filter(l, pat))
            else:
                return l[0]

        try:
            lists = self.get_lists_list()
            res = fnmatch.filter(lists, pattern)

            if len(res) > 1:
                return match_listname(res)
            else:
                return res[0]

        except HTTPError:
            bailout("Unable to glob list pattern")

class CommandParser(object):
    def __init__(self, args):
        self.dispatch = {"create" : self.parse_create,
                         "c" : self.parse_create,
                         "touch" : self.parse_create,
                         "remove" : self.parse_remove,
                         "rem" : self.parse_remove,
                         "rm" : self.parse_remove,
                         "show" :   self.parse_show, 
                         "s" :   self.parse_show,
                         "update" : self.parse_update,
                         "add" : self.parse_add,
                      }

        if args[0] in self.dispatch:
            self.dispatch[args[0]](args[1:])

    def parse_create(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            bailout("liszt create listname [optional entry name]")

        listname = args[0]

        if len(args) == 2:
            entryname = args[1]
        elif len(args) > 2:
            # It means that we've got something like "liszt create mylist buy something from the grocery store"
            def addstr(x, y):
                # A special function to add spaces between to added words - yes, it doesn't preserve tabulations and the likes,
                # but, you asked for it.
                return x + " " + y
            entryname = reduce(addstr, args[1:])
        
        if entryname == "":
            session.create_list(listname)
        else:
            session.create_list_entry(listname, entryname)

    def parse_show(self, args):
        listname = ""
        entryname = ""

        if sys.stdin.isatty():
            sys.stdin = os.popen('/bin/sh -c less -', 'w')

        if len(args) == 0:
            print "List of the created lists :"
            for list in session.get_lists_list():
                print list

        if len(args) == 1:
            entries = session.get_list(args[0])

            for entry in entries["contents"]:
                print entry["title"] + "\t" + entry["date"]

        elif len(args) == 2:
            entry = session.get_entry(args[0], args[1])
            print entry["title"] + "\t" + entry["date"]

    def parse_remove(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            bailout("liszt rm listname [optional entry index]")

        if len(args) == 1:
            session.remove_list(args[0])
            print "removed list " + args[0]

        elif len(args) == 2:
            session.remove_list_entry(args[0], args[1])
            print "removed from list " + args[0] + " entry #" + args[1] 
        pass
    
    def parse_update(self, args):

        listname = ""

        if len(args) == 0:
            bailout("liszt update listname [optional entry index]")

        listname = args[0]

        if len(args) == 1:
            fd, filename = tempfile.mkstemp()

            entries = session.get_list(listname)["contents"]

            for entry in entries:
                str = "+\t%s\t%s\t%s\n" % (entry["title"], entry["date"], entry["done"])
                os.write(fd, str)

            editor = os.getenv("EDITOR")
            os.system(editor + " " + filename)
            os.close(fd)
            
            # Now, reopen the fd, as a python file handle.
            fd = open(filename)
            dict = {"contents" : []}
            lines = fd.readlines()

            for i in range(len(lines)):
                fields = lines[i].split("\t")
                if len(fields) != 4:
                    bailout("Error : one of the fields is not correctly formatted.") # FIXME : display the line number too.

                dict = {"title" : fields[1], "date" : fields[2], "done": fields[3]}
                print dict
                session.update_list_entry(listname, i, dict)

            os.unlink(filename)

    def parse_add(self, args):
        listname = ""

        if len(args) == 0:
            bailout("liszt add listname ")

        listname = args[0]

        fd, filename = tempfile.mkstemp()

        editor = os.getenv("EDITOR")
        os.system(editor + " " + filename)
        os.close(fd)
        
        # Now, reopen the fd, as a python file handle.
        fd = open(filename)
        lines = fd.read().split('+')

        for i in range(len(lines)):
            # fields = lines[i].split("\t")  FIXME: add support for different fields on a line.
            
            if lines[i] != '':
                session.create_list_entry(listname, lines[i].rstrip().lstrip())

        os.unlink(filename)

if __name__ == "__main__":

    if len(sys.argv) <= 1:
        help()
        sys.exit(0)

    session = LisztSession()
    session.login(username, password)
    parser = CommandParser(sys.argv[1:])
