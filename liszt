#!/usr/bin/env python
# 

import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError, URLError
import subprocess
from subprocess import Popen
import fnmatch
import tempfile

import ConfigParser

try:
    import json 
except ImportError:
    import simplejson as json                                                                                                                         


base = "http://soundbush.com:8080/api/v1"

conf = ConfigParser.RawConfigParser()
conf.read(os.path.expanduser('~/.liszt/config'))
username = conf.get('Credentials', 'username')
password = conf.get('Credentials', 'password')

def help():
    print "liszt c|create listname ?entryname? "
    print "liszt r[remove|d|delete listname ?entryindex?"
    print "liszt s listname ?entryindex?"
    print "liszt chk|check listname index"
    print "liszt u|update listname index ?'new description'? ?'check'? ?'date'?"
    

def bailout(msg):
    print msg
    sys.exit(-1)

def create_spool_file(dict):
# Create a spool file and save dict inside as a json dict.
    fd, filename = tempfile.mkstemp(dir=os.path.expanduser('~/.liszt/delayed/'))
    os.write(fd, json.dumps(dict))
    os.close(fd)
    
    
class CommandParser(object):
    def __init__(self, args):
        self.dispatch = {"create" : self.parse_create,
                         "c" : self.parse_create,
                         "touch" : self.parse_create,
                         "remove" : self.parse_remove,
                         "rem" : self.parse_remove,
                         "rm" : self.parse_remove,
                         "show" :   self.parse_show, 
                         "s" :   self.parse_show,
                         "update" : self.parse_update,
                         "add" : self.parse_add,
                      }

        if args[0] in self.dispatch:
            self.dispatch[args[0]](args[1:])

    def parse_create(self, args):
        listname = ""
        entryname = ""
        spldict = {} # The dictionnary saved in a spool file.

        if len(args) == 0:
            bailout("liszt create listname [optional entry name]")

        listname = args[0]

        if len(args) == 2:
            entryname = args[1]
        elif len(args) > 2:
            # It means that we've got something like "liszt create mylist buy something from the grocery store"
            def addstr(x, y):
                # A special function to add spaces between to added words - yes, it doesn't preserve tabulations and the likes,
                # but, you asked for it.
                return x + " " + y
            entryname = reduce(addstr, args[1:])
        
        if entryname == "":
            spldict["request"] = "create-list"
            spldict["listname"] = listname
            
        else:
            spldict["request"] = "create-entry"
            spldict["listname"] = listname
            spldict["content"] = dict()
            spldict["content"]["title"] = entryname # FIXME : specify the other options.

        create_spool_file(spldict)
            

    def parse_show(self, args):
        listname = ""
        entryname = ""

        if sys.stdin.isatty():
            sys.stdin = os.popen('/bin/sh -c less -', 'w')

        if len(args) == 0:
            print "List of the created lists :"
            lists = open(os.path.expanduser('~/.liszt/cache/lists_list'))
            for list in lists.readlines():
                print list

        if len(args) == 1:
            listfd = open(os.path.expanduser('~/.liszt/cache/lists_list') + args[0])
            list = json.load(listfd)
            print list
#             for entry in entries["contents"]:
#                 print entry["title"] + "\t" + entry["date"]

#         elif len(args) == 2:
#             entry = session.get_entry(args[0], args[1])
#             print entry["title"] + "\t" + entry["date"]

    def parse_remove(self, args):
        listname = ""
        index = ""
        spldict = {} # The dictionnary saved in a spool file.

        if len(args) == 0 or len(args) > 2:
            bailout("liszt remove listname [optional entry index]")

        listname = args[0]

        if len(args) == 2:
            index = int(args[1])
            spldict["request"] = "delete-entry"
            spldict["index"] = index
            spldict["listname"] = listname
        else:
            spldict["request"] = "delete-list"
            spldict["listname"] = listname

        create_spool_file(spldict)
    
    def parse_update(self, args):

        listname = ""

        if len(args) == 0:
            bailout("liszt update listname [optional entry index]")

        listname = args[0]

        if len(args) == 1:
            fd, filename = tempfile.mkstemp()

            entries = session.get_list(listname)["contents"]

            for entry in entries:
                str = "+\t%s\t%s\t%s\n" % (entry["title"], entry["date"], entry["done"])
                os.write(fd, str)

            editor = os.getenv("EDITOR")
            os.system(editor + " " + filename)
            os.close(fd)
            
            # Now, reopen the fd, as a python file handle.
            fd = open(filename)
            lines = fd.read().split('+')

            for i in range(len(lines)):
                fields = lines[i].split("\t")
                if len(fields) != 4:
                    bailout("Error : one of the fields is not correctly formatted.") # FIXME : display the line number too.

                dict = {"request" : "update-entry", "listname" : listname,
                        "index" : i, "contents" : {"title" : fields[1], "date" : fields[2], "done": fields[3]}}

                create_spool_file(dict)

            os.unlink(filename)

    def parse_add(self, args):
        listname = ""

        if len(args) == 0:
            bailout("liszt add listname ")

        listname = args[0]

        fd, filename = tempfile.mkstemp()

        editor = os.getenv("EDITOR")
        os.system(editor + " " + filename)
        os.close(fd)
        
        # Now, reopen the fd, as a python file handle.
        fd = open(filename)
        lines = fd.read().split('+')

        for i in range(len(lines)):
            # fields = lines[i].split("\t")  FIXME: add support for different fields on a line.
            
            if lines[i] != '':
                session.create_list_entry(listname, lines[i].rstrip().lstrip())
                dict = {"request" : "create-entry", "listname" : listname, "contents" : {"title" : lines[i]}}
                create_spool_file(dict)

        os.unlink(filename)

if __name__ == "__main__":

    if len(sys.argv) <= 1:
        help()
        sys.exit(0)

    parser = CommandParser(sys.argv[1:])
