#!/usr/bin/env python
# 
import sys
import os
from datetime import datetime
import urllib, urllib2, cookielib
from urllib import quote
from urllib2 import HTTPError, URLError
import fnmatch
import operator

import ConfigParser

try:
    import json 
except ImportError:
    import simplejson as json                                                                                                                         


base = "http://0.0.0.0:8080/api"

conf = ConfigParser.RawConfigParser()
conf.read(os.path.expanduser('~/.liszt/config'))
username = conf.get('Credentials', 'username')
password = conf.get('Credentials', 'password')

def bailout(msg):
    print msg
    sys.exit(-1)

class LisztSession:
    def __init__(self):

        self.jar = cookielib.LWPCookieJar()
        if os.path.isfile('~/.liszt/cookiejar'):
            self.jar.load('~/.liszt/cookiejar')

        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.jar))
        urllib2.install_opener(self.opener)

    def snappy(func):
        def wrapper(instance, *args):
            if os.fork():
                sys.exit(0)
            else:
                func(instance, *args)
                sys.exit(0)
        return wrapper

    def login(self, username, password):
        d = {'username' : username, 'password': password}
        ed = urllib.urlencode(d)
        try:
            urllib2.urlopen(base + "/login/", ed)
        except HTTPError:
            bailout("Unable to log you in - are you credentials correct ?")
        except URLError:
            bailout("Unable to connect to the remote host.")

    def create_list(self, listname):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to create the list " + listname)

    def create_list_entry(self, listname, entry):
        try:
            urllib2.urlopen(base + "/create/" + quote(listname) + "/" + quote(entry) + "/")
        except HTTPError:
            bailout("Unable to create the list entry in list " + listname)

    def get_lists_list(self):
        try:
            req = urllib2.urlopen(base + "/getlists/")
        except HTTPError:
            bailout("Unable to get a list of the available lists")
            
        return json.load(req)

    def show_list(self, listname):
        ln = self.glob_listname(listname)

        try:
            req = urllib2.urlopen(base + "/get/" + quote(ln) + "/")
        except HTTPError:
            bailout("Unable to open the list " + listname)

        entries = json.load(req)

        for entry in entries["contents"]:
            print entry["title"] + "\t" + entry["date"]

    def show_entry(self, listname, index):
        ln = self.glob_listname(listname)

        try:
            req = urllib2.urlopen(base + "/get/" + quote(ln) + "/" + str(index) + "/")
        except HTTPError:
            bailout("Unable to get entry " + str(index) + " from list " + listname)

        entry = json.load(req)

        print entry["title"] + "\t" + entry["date"]

    def remove_list(self, listname):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/")
        except HTTPError:
            bailout("Unable to remove the list " + listname)

    def remove_list_entry(self, listname, index):
        try:
            urllib2.urlopen(base + "/remove/" + quote(listname) + "/" + quote(index) + "/")
        except HTTPError:
            bailout("Unable to remove the entry " + index + "from list " + listname)

    def glob_listname(self, pattern):
        
        def match_listname(l):
            # This function doesn't seem very pythonic...
            if len(l) > 1:
                print str(len(l)) + " lists satifisfy the pattern : "
                print l

                try:
                    pat = raw_input("Enter a matching pattern to clarify your choice : ")
                except EOFError:
                    sys.exit(-1)

                return match_listname(fnmatch.filter(l, pat))
            else:
                return l[0]

        try:
            lists = self.get_lists_list()
            res = fnmatch.filter(lists, pattern)

            if len(res) > 1:
                return match_listname(res)
            else:
                return res[0]

        except HTTPError:
            bailout("Unable to glob list pattern")

class CommandParser(object):
    def __init__(self, args):
        self.dispatch = {"create" : self.parse_create,
                         "c" : self.parse_create,
                         "touch" : self.parse_create,
                         "remove" : self.parse_remove,
                         "rem" : self.parse_remove,
                         "rm" : self.parse_remove,
                         "show" :   self.parse_show, 
                         "s" :   self.parse_show, }

        if args[0] in self.dispatch:
            self.dispatch[args[0]](args[1:])

    def help():
        print "liszt c|create listname ?entryname? "
        print "liszt r[remove|d|delete listname ?entryindex?"
        print "liszt s listname ?entryindex?"
        print "liszt chk|check listname index"
        print "liszt~ m|mod|modify listname index ?'new description'? ?'check'? ?'date'?"
    
    def parse_create(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            bailout("liszt create listname [optional entry name]")

        listname = args[0]

        if len(args) == 2:
            entryname = args[1]
        elif len(args) > 2:
            # It means that we've got something like "liszt create mylist buy something from the grocery store"
            def addstr(x, y):
                # A special function to add spaces between to added words - yes, it doesn't preserve tabulations and the likes,
                # but, you asked for it.
                return x + " " + y
            entryname = reduce(addstr, args[1:])
        
        if entryname == "":
            session.create_list(listname)
        else:
            session.create_list_entry(listname, entryname)

    def parse_show(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            for list in session.get_lists_list():
                print list

        if len(args) == 1:
            session.show_list(args[0])
        elif len(args) == 2:
            session.show_entry(args[0], args[1])


    def parse_remove(self, args):
        listname = ""
        entryname = ""

        if len(args) == 0:
            bailout("liszt rm listname [optional entry index]")

        if len(args) == 1:
            session.remove_list(args[0])
            print "removed list " + args[0]

        elif len(args) == 2:
            session.remove_list_entry(args[0], args[1])
            print "removed from list " + listname + "entry #" + args[1] 
        pass
    


if __name__ == "__main__":

    if len(sys.argv) <= 1:
        help()
        sys.exit(0)

    session = LisztSession()
    session.login(username, password)
    parser = CommandParser(sys.argv[1:])
